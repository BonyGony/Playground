## 4장 처리율 제한 장치의 설계

<b>처리율 제한 장치(rate limiter)</b>  
ㄴ 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치  
ㄴ 요청 횟수가 제한 장치에 정의된 임계치(threshold)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(block)  
ㄴ DoS(Denial of Service) 공격에 의한 자원 고갈을 방지  
ㄴ 비용 절감, 추가 요청에 대한 처리를 제한하여 서버 리소스를 아끼고, 우선순위가 높은 API에 더 할당 가능  
ㄴ 보통 API 게이트웨이라 불리는 컴포넌트에 구현 (API 게이트웨이는 처리율 제한, SSL 종단, 사용자 인증, IP 허용 목록 관리 등을 지원하는 완전 위탁관리형 서비스)  

<b>처리율 제한 알고리즘</b>  
ㄴ 토큰 버킷(token bucket)  
ㄴ 누출 버킷(leky bucket)  
ㄴ 고정 위도 카운터(fixed window counter)  
ㄴ 이동 윈도 로그(sliding window log)  
ㄴ 이동 윈도 카운터(sliding window counter)  

<b>개략적인 아키텍처</b>  
ㄴ 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 두고, 이 카운터의 값이 어떤 한도들 넘어서면 한도를 넘어 도착한 요청은 거부하는 것  
ㄴ 데이터베이스는 디스크 접근 때문에 느려, 메모리상에서 동작하는 캐시가 바람직  
&nbsp;&nbsp;&nbsp;&nbsp;ㄴ 빠른데다 시간에 기반한 만료 정책을 지원  
&nbsp;&nbsp;&nbsp;&nbsp;ㄴ 일례로 레디스는 처리율 제한 장치를 구현할 때 자주 사용되는 메모리 기반 저장장치로 INCR과 EXPIRE의 두 가지 명령어를 지원  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INCR: 메모리에 저장된 카운터의 값을 1만큼 증가  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXPIRE: 카운테에 타임아웃 값을 설정  
ㄴ 클라이언트가 처리율 제한 미들웨에게 요청, 레디스의 지정 버킷에서 카운터를 가져와 한도 검사  
ㄴ 한도에 도달하지 않았다면 요청은 API 서버로 전달, 미들웨어는 카운터의 값을 증가시킨 후 레디스에 저장

<b>처리율 제한 장치가 사용하는 HTTP 헤더</b>  
ㄴ 클라이언트는 자기 요청이 처리율 제한에 걸리기까지 요청을 응답 헤더를 통해 알 수 있음  
ㄴ 처리율 제한 장치는 다음의 HTTP 헤더를 클라이언트로 보냄  
&nbsp;&nbsp;&nbsp;&nbsp;X-Ratelimit-Remaining: 윈도 내에 남은 처리 가능 요청의 수  
&nbsp;&nbsp;&nbsp;&nbsp;X-Ratelimit-Limit: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수  
&nbsp;&nbsp;&nbsp;&nbsp;X-Ratelimit-Retry-After: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림  
ㄴ 사용자가 너무 많은 요청을 보내면 429 too mant requests 오류를 X-Ratelimit-Retry-After 해더와 함께 반환  

<b>동기화 이슈</b>  
ㄴ 트래픽이 증가하면 한 대의 처리율 제한 장치로는 한계가 있음, 여러 대를 두게 되면 동기화가 필요해짐  
ㄴ 웹 계층은 무상태이므로 동기화를 하지 않는다면, 클라이언트는 각기 다른 제한 장치로 요청을 보내고 제한 장치는 다른 클라이언트의 요청을 알지 못해 올바른 수행을 할 수 없음  
ㄴ 같은 클라이언트로부터의 요청을 항상 같은 처리율 제한 장치로 보낸다면 쉽게 해결 되지만, 규모 확장과 유연성에 제한적  
ㄴ 동기화 이슈의 더 나은 해결책은 레디스와 같은 중앙 집중형 데이터 저장소를 사용  


